磁盘IO：
    读/写IO，最为常见说法，读IO，就是发指令，从磁盘读取某段扇区的内容。
    指令一般是【通知磁盘开始扇区位置，然后给出需要从这个初始扇区往后读取的连续扇区个数，同时给出动作是读，还是写】。
    磁盘收到这条指令，就会按照指令的要求，读或者写数据。控制器发出的这种指令＋数据，就是一次IO，读或者写。

linux 同步IO:
    当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，
    而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，
    才进行实际的I/O操作。

    这种输出方式被称为延迟写（delayed write）延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度


sync、fsync和fdatasync三个函数。
      (1) sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。

      (2) fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。
      (3) fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。

     <fsync不但更新数据，还会更新元数据——文件的属性，但fdatasync仅更新数据>

      对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。

      一个简单的问题：在linux/unix操作系统上，怎样保证对文件的更新内容成功持久化到硬盘？



====================================================================================
参考：https://blog.csdn.net/chengweiuser/article/details/76522244

从磁盘到B树到B+树
    1、主存和磁盘之间的数据交换不是以字节为单位的，而是以n个扇区为单位的（一个扇区有512字节），通常是4KB（8个扇区），
    8KB（16个扇区），16KB，……64KB为单位的。
索引的步骤：
    1、首先我们要读取这个B+树的根结点【读入到内存】（花费一个IO的时间）
    2、根据根节点信息，再将字节点信息读入内存，进行判断。
    3、最后找到叶子节点信息。

1、也就是说【树的每个节点都需要进行一次IO】，需要先将上层的某个节点的数据读入内存，进行计算判断，才能得出下一层是哪个节点。
    比如二叉树：先将根节点读入内存，和当前的数字进行比较后，判断走哪个子节点。

2、故而，【树的深度过大会造成磁盘I/O读写过于频繁】，进而导致查询效率低下。
    一棵含n个结点的二叉树的高度为（log2n），二叉树的时间复杂度是  log2n   以2为底n的对数。


3、如何减少二叉树的深度？
    采用多叉树的结构。就提出了一个新的查找树结构——多路查找树
4、B-tree
    （B-tree树即B树，B即Balanced，平衡的意思)。


5、磁盘
    计算机存储设备一般分为两种：内存储器(main memory)和外存储器(external memory)。
    内存：存取速度快，但容量小，价格昂贵，而且不能长期保存数据(在不通电情况下数据会消失)。
    外存储器：磁盘是一种直接存取的存储设备(DASD)。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。

6、磁盘的
    当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，
    【当磁道在读/写头(又叫磁头) 下通过时】，就可以进行数据的读 / 写了。

    一般磁盘分为固定头盘(磁头固定)和活动头盘。
    固定头盘：【每一个磁道上都有独立的磁头】，它是固定不动的，专门负责这一磁道上数据的读/写。

    活动头盘 ：磁头是可移动的。每一个盘面上只有一个磁头(磁头是双向的，因此正反盘面都能读写)。
    它可以【从该面的一个磁道移动到另一个磁道】。所有磁头都装在同一个动臂上，因此不同盘面上的【所有磁头都是同时移动的】(行动整齐划一)。
    当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面。
    因此，【柱面的个数也就是盘面上的磁道数】。

7、磁盘的读/写原理和效率
    磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号(磁道上的盘块)。

    读/写磁盘上某一指定数据需要下面3个步骤：

    (1)  首先【移动臂根】据柱面号【使磁头移动到所需要的柱面上】，这一过程被称为定位或查找 。

    (2)  这时根据盘面号来确定【指定】盘面上的磁道。（也就是确定盘面）

    (3) 盘面确定以后，盘片开始旋转，将【指定块号的磁道段移动至磁头下】。

    经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作了。

    磁盘读取数据是以盘块(block)为基本单位的。位于【同一Block中】的所有数据都【能被一次性全部读取出来】。
    而【磁盘IO】代价主要花费在【查找时间Ts】上。因此我们应该【尽量将相关信息存放在【同一盘块】，【同一磁道中】。
    或者【至少放在同一柱面或相邻柱面上】，以求在读/写信息时尽量减少磁头来回移动的次数，避免过多的查找时间Ts。


8、B-树 什么是b-树
    再次强调下：【B-树】，即为B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，
    其实，这是个非常不好的直译，很容易让人产生误解。

8.1、 B树是为了磁盘或其它存储设备而设计的一种【多叉平衡查找树】。
    B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。

    那为什么又说B树与红黑树很相似呢?
    因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能【比一棵红黑树的高度小许多】，应为它的分支因子比较大。
    所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

===================================================================================================

参考文章：https://www.cnblogs.com/jswang/p/9071847.html

盘片（platter）、磁头（head）、磁道（track）、扇区（sector）、柱面（cylinder）
1、盘片 片面 和 磁头
    硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。
    受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。

    盘片的编号【自下向上】从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。
    如图：盘面和磁头。

    每一盘片上有两个面，除去最顶端和最底端的外侧面不存储数据（也没有磁头能读到他们。）


2、扇区 和 磁道（如图：扇区和磁道.png）
    盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以【将磁道划分为若干个弧段】，
    【每个磁道上一个弧段被称之为一个扇区】（图践绿色部分）。
    【扇区是磁盘的最小组成单元，通常是512字节】。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）

    数据记录在磁道上。当磁头在磁道上面通过事后，就可以进行数据的读写了。

3、磁头 和 柱面 （如图：磁头和柱面.png）
   硬盘通常由重叠的【一组盘片】构成
   每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，
   【具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面】。

   磁盘的柱面数与一个盘面上的磁道数是相等的。
   由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数

4、磁盘容量计算
    存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数
    图3中磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：
    存储容量 6 * 7 * 12 * 512 = 258048
    每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。

5、磁盘读取响应时间
    1、寻道时间：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。
    2、旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。
    3、数据传输时间：完成传输所请求的数据所需要的时间。

    小结一下：从上面的指标来看、其实最重要的、或者说、我们最关心的应该只有两个：寻道时间；旋转延迟。

    4、读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，【软件应着重考虑减少寻道时间和延迟时间】。

6、块/簇
  磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。【操作系统与磁盘打交道的最小单位是磁盘块】。
  通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。
  每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。

  为什么存在磁盘块？
  读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，
  所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。

  分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为【块是最小的单位】。

7、page
    操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。
    所以，【与内存操作，是虚拟一个页的概念】来作为最小单位。【与硬盘打交道，就是以块为最小单位】。

8、扇区、块/簇、page的关系
    扇区： 硬盘的最小读写单元
    块/簇： 是操作系统针对硬盘读写的最小单元
    page： 是内存与操作系统之间操作的最小单元。
    扇区 <= 块/簇 <= page


















